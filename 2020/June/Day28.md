# 2020.06.28 Sunday - Spring @Order, 객체 의존성 관리

### Table of Contents

- [@Order](#@Order)
    - [Ordered](#Ordered)
    - [PriorityOrdered](#PriorityOrdered)
- [객체 의존성 관리](#객체_의존성_관리)
- [유연한 설계](#유연한_설계)
    

# @Order

`@Order`는 컴포넌트의 정렬 순서를 정의하는 어노테이션이다. 특정 컴포넌트에 Collection 주입 인자가 있는 경우 해당 Collection에 포함되는 컴포넌트들의 정렬 순서를 결정하는데 사용한다. 또한, `@ControllerAdvice`의 적용 순서를 정의하는데 사용하기도 한다. `ControllerAdviceBean 참고`

```java
@Order(COMMON_ADVICE_PRIORITY)
@ControllerAdvice
public class CommonControllerAdvice {
    public static final int COMMON_ADVICE_PRIORITY = 1;

    // ...
}

@Order(HIGHER_COMMON_ADVICE_PRIORITY)
@ControllerAdvice
public class PostControllerAdvice {
    public static final int HIGHER_COMMON_ADVICE_PRIORITY = 0;

    // ...
}
```

숫자가 낮을수록 우선순위가 높다. 이때 Order의 value는 주입 지점의 우선 순위에 영향을 미칠 수는 있지만 싱글톤 시작 순서에 영향을 미치지는 않는다. 즉, 빈 생성은 우선순위에 상관없이 모두 생성되지만 주입은 Order 값에 따라 주입됨.

`@Order` 어노테이션 기반의 ordering은 Spring 4.0부터 지원을 한다. `Spring 4.0부터 컴포넌트에 Collection 주입이 가능` 그리고 Spring 4.1부터는 `javax.annotation.Priority`를 Order 대신 사용할 수 있게 되었다. 단, `@Priority`는 단일 요소를 선택해야하는 경우 추가적인 의미를 가질 수 있다. `AnnotationAwareOrderComparator#getPriority 참고`

> selecting one object over another in case of multiple matches but only one object to be returned.
즉, 우선순위가 겹치는 여러 요소들 중 하나만 고른다는 의미로 해석.

`@Order`의 대안으로는 빈으로 생성하려는 클래스를 Ordered나 PriorityOrdered로 구현하는 방법이 있다. 이때 우선순위는 `getOrder` 메서드를 구현하여 설정할 수 있다.

## Ordered

Ordered는 Collection과 같이 정렬이 가능한 객체에 의해서 구현이 될 수 있다.

```java
public interface Ordered {

    int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;

    int LOWEST_PRECEDENCE = Integer.MAX_VALUE;

    int getOrder();

}
```

실제로 `getOrder`는 우선순위를 정하는데 사용된다.

### PriorityOrdered

Ordered의 확장 인터페이스로 우선순위를 표시하기 위한 마커 인터페이스이다. PriorityOrdered는 Ordered보다도 우선하여 적용된다.

Spring에서는 PriorityOrdered로 구현한 경우 Order보다 더 우선하여 정렬한다. 만약 둘다 PriorityOrdered인 경우는 똑같이 `getOrder`의 값으로 비교한다.

# 객체 의존성 관리

> 조영호님의 오브젝트 8장을 학습, 정리한 내용입니다.

객체  간 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션 수정을 어렵게한다. 객체지향의 핵심은 협력을 위해 필요한 의존성은 유지하면서 변경을 방해하는 의존성은 제거하는데 있다.

## 의존성이란

의존성이란 변경에 의한 전파 가능성을 의미한다. 즉, 어떤 특정 클래스에서 의존하는 객체들이 변경되는 경우 미치는 영향도이다.

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재한다. 이때 의존성은 실행 시점과 구현 시점에 다른 의미를 가진다.

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경되는 경우 의존하는 객체도 함께 변경된다.

## 의존성 전이

의존성은 전이될 수 있다. 만약 어떤 객체 `A 객체`가 다른 객체 `B 객체`를 의존한다면 B 객체가 의존하는 대상에 대해서도 자동적으로 의존한다. 단, 의존성이란 함께 변경될 수 있는 가능성을 의미한다. 때문에 모든 경우에 의존성 전이가 이뤄지는 것은 아니다.

의존성 전이의 여부는 **변경의 방향과 캡슐화 정도**에 따라 달라진다. 만약 B 객체가 변경에 따른 내부 구현을 효과적으로 캡슐화하고 있다면 A 객체로 변경이 전파되지 않을 것이다.

### 직접 의존성과 간접 의존성

의존성은 직접 의존성과 간접 의존성으로 종류를 나누기도 한다.

- 직접 의존성: 다른 객체에 직접 의존하는 경우
- 간접 의존성: 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우

## 런타임 의존성과 컴파일타임 의존성

런타임 의존성이란 실제 애플리케이션이 동작할 때 어떤 객체가 의존하는 객체를 의미한다. 반면 컴파일타임 의존성은 작성된 코드를 컴파일 할 때의 객체가 의존하는 객체를 의미한다. 

이때 컴파일타임 의존성은 동적 언어 `컴파일타임이 없음`, 정적 언어마다 그 시점이 달라지는데 코드 작성 시점인지 코드가 컴파일 되는 시점인지 파악하는 것이 중요하다.

런타임 의존성과 컴파일타임 의존성은 다를 수 있다. 사실 유연하고 재사용 가능한 코드를 만들기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.

어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다. 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야한다.

## 컨텍스트 독립성

클래스가 특정한 문맥에 강하게 연결될수록 다른 문맥에서 사용되기 어렵다. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기 수월해진다. 이를 **컨텍스트 독립성**이라고 한다.

설계가 유연해지기 위해서는 가능한 자신이 실행될 컨텍스트에 대한 정보를 최대한 적게 알아야한다.

## 의존성 해결

컴파일타임 의존성은 런타임 의존성으로 대체되어야한다. 즉, 추상에 의존하는 객체가 실제 애플리케이션에서는 실제 구현 객체를 의존해야함을 의미한다. 이때 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 **의존성 해결**이라고 부른다.

의존성 해결에는 3가지 방법이 있다.

- 객체를 생성하는 시점에 생성자를 통해 해결
- setter로 해결
- 메서드 호출시 인자로 해결

# 유연한 설계

## 의존성과 결합도

결합도는 한 객체가 다른 객체를 구체적으로 알수록 강하다. 흔히 유연한 설계는 낮은 결합도, 높은 응집도를 말한다. 따라서 낮은 결합도를 이루기 위해서는 객체가 추상에 의존하도록 만들어야한다.

## 명시적인 의존성

명시적인 의존성이란 퍼블릭 인터페이스에 의존성을 드러내는 것을 의미한다. 반면 숨겨진 의존성은 퍼블릭 인터페이스에 표현되지 않은 의존성을 의미한다.

의존성이 명시적이지 않으면 의존성 파악을 위해 내부 구현을 직접 살펴볼 수 밖에 없다. 커다란 클래스에 정의된 긴 메서드 내부에서 코드를 파악하는 것은 쉽지 않을 수 있다.

더 큰 문제는 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용 하기 위해  내부 구현을 변경해야한다. 의존성을 명시적으로 드러내면 코드를 직접 수정해야하는 위험에서 벗어날 수 있다.

따라서 의존성은 명시적으로 드러나야한다. 이를 통해 런타임에서 적절한 의존성으로 교체할 수 있으며 설계가 유연해진다.