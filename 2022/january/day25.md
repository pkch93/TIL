# 2022.01.25 TIL - MySQL 아키텍처 (MySQL의 전체 구조, MySQL 스레딩 구조)

- [2022.01.25 TIL - MySQL 아키텍처 (MySQL의 전체 구조, MySQL 스레딩 구조)](#20220125-til---mysql-아키텍처-mysql의-전체-구조-mysql-스레딩-구조)
  - [MySQL의 전체 구조](#mysql의-전체-구조)
    - [MySQL 엔진](#mysql-엔진)
    - [스토리지 엔진](#스토리지-엔진)
    - [핸들러 API](#핸들러-api)
  - [MySQL 스레딩 구조](#mysql-스레딩-구조)
    - [포그라운드 스레드](#포그라운드-스레드)
    - [백그라운드 스레드](#백그라운드-스레드)
  - [참고](#참고)

## MySQL의 전체 구조

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

### MySQL 엔진

MySQL 엔진은 클라이언트로부터 접속 및 요청을 처리하는 **커넥션 핸들러**와 **SQL 파서, 전처리기, 옵티마이저**를  중심으로 한다. 또한 MySQL은 표준 SQL `ANSI SQL` 문법을 지원하므로 표준 SQL 문법으로 작성된 쿼리는 타 DBMS와 호환하여 실행할 수 있다.

즉, MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS 두뇌에 해당하는 처리를 한다.

### 스토리지 엔진

스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지에서 데이터를 읽어오는 부분을 담당한다. MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.

MySQL은 MyISAM, InnoDB 등의 스토리지 엔진을 지원한다.

### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽는 경우에는 각 스토리지 엔진에 데이터 쓰기, 읽기 요청을 하는데 이를 핸들러 요청이라고 하고 요청에 사용하는 API를 핸들러 API라고 한다.

만약 어떤 핸들러 API가 얼마나 요청이 왔는지는 `'SHOW GLOBAL STATUS LIKE 'Handler%';`  명령으로 확인할 수 있다.

## MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아닌 스레드를 기반으로 동작한다. 스레드에는 포그라운드 스레드 `foreground thread`와 백그라운드 스레드 `background thread`로 구분할 수 있다.

MySQL 서버에서 실행중인 스레드의 목록은 `performance_schema` 데이터베이스의 `threads` 테이블에서 확인이 가능하다.

```sql
SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema.threads ORDER BY type, thread_id;
```

### 포그라운드 스레드

포그라운드 스레드는 MySQL 서버에 접속된 클라이언트 수만큼 존재한다. 클라이언트가 요청하는 쿼리를 처리하는 것을 담당하며 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당한 스레드는 스레드 캐시에 되돌아간다. 만약 스레드 캐시에 유지해야하는 최대 스레드 개수가 존재한다면 스레드 캐시에 되돌아가지 않고 종료시킨다.

스레드 캐시에 유지해야하는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 지정할 수 있다.

MyISAM에서는 포그라운드 스레드가 MySQL 데이터 버퍼나 캐시에서 데이터를 가져오거나 만약 버퍼나 캐시에 없는 데이터는 직접 디스크나 인덱스를 통해 읽어온다. 반면 InnoDB에서는 데이터 버퍼나 캐시까지만 포그라운드 스레드에서 처리하고 버퍼에서 디스크까지 데이터를 기록하는 작업은 백그라운드 스레드에 넘긴다.

### 백그라운드 스레드

MyISAM 엔진에서는 백그라운드 스레드를 사용하지 않지만 InnoDB에서는 백그라운드 스레드를 사용한다.

백그라운드 스레드는 다음과 같은 역할을 한다.

- Insert Buffer를 병합
- 로그를 디스크로 기록
- InnoDB 버퍼 풀의 데이터를 디스크에 기록
- 데이터를 버퍼로 읽어옴
- Lock이나 DeadLock 모니터링

여기서 로그 기록하는 스레드와 데이터를 디스크로 쓰는 쓰기 스레드가 가장 중요하다.

> MySQL 5.5 버전부터 데이터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정할 수 있다. 각각 `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 스레드 개수를 설정할 수 있다.

InnoDB에서도 읽기 작업은 클라이언트 스레드에서 처리하기 때문에 읽기 스레드를 많이 둘 필요는 없지만 쓰기 스레드는 백그라운드로 처리한다.

보통 읽기 작업은 **절대 지연되지 않는 반면** 쓰기 작업은 **버퍼링되어 처리될 수 있다**. 때문에 일반 상용 DBMS는 대부분 쓰기 작업을 버퍼링하여 일괄 처리하는 기능을 제공한다. InnoDB에서도 이와 같은 방식으로 처리한다. 단, MyISAM에서는 사용자 스레드가 함께 처리하도록 구현되어있다. 따라서 InnoDB는 INSERT, UPDATE, DELETE 쿼리에서 데이터가 변경되는 경우에 디스크에 쓸때까지 기다리지 않아도 된다. 반면, MyISAM은 쓰기 버퍼링 기능을 사용할 수 없다.

## 참고

[Real MySQL 8.0 1권 - 4장 아키텍처](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791158392703)