# Day10

## 19.11.10 Sunday

## 1. 인덱스 튜닝

DBMS 테이블에서 데이터를 찾는 방법은 두 가지이다.

* 테이블 전체 스캔
* 인덱스 활용

테이블 전체 스캔은 튜닝 요소가 많지 않지만 인덱스 관련한 튜닝 요소는 매우 많고 기법도 다양하다. 따라서 인덱스 튜닝은 SQL 튜닝의 가장 기본이다.

### 인덱스 튜닝의 핵심요소

인덱스는 데이터가 많은 테이블에서 소량의 데이터를 검색할 때 사용한다.

#### 1. 인덱스 스캔 과정의 비효율 최소화

즉, 인덱스 스캔을 효율화하는 방법이다. 이는 인덱스가 어떻게 생성되는지 알아야 비효율을 축소할 수 있다.

복합 인덱스를 만드면 인덱스의 정렬은 선행 칼럼에 영향을 받는다. 따라서 카디널리티가 높은 컬럼이 인덱스의 선행 컬럼이 되면 스캔 과정의 비효율을 줄일 수 있다.

#### 2. 테이블 엑세스 최소화

즉, 랜덤 엑세스를 최소화하는 방법이다.

원하는 데이터가 인덱스가 아닌 테이블에 있다면 테이블에 접근하는 랜덤 엑세스를 최소화하도록 만들어야한다. 이는 모델링, 비즈니스 로직에 영향을 받으며 이를 잘 판단해야한다.

위 두 핵심 요소 중 테이블 엑세스를 최소화하는 것이 더 중요하다. 성능에 더 큰 영향을 미치기 때문이다.

### 인덱스 구조

B+Tree와 B-Tree 참고: [https://wangin9.tistory.com/entry/B-tree-B-tree](https://wangin9.tistory.com/entry/B-tree-B-tree)

인덱스는 다양한 자료구조를 사용할 수 있지만 대부분의 DBMS에서는 B+Tree 구조를 사용한다. B Tree를 이야기하면 흔히 B-Tree와 B+Tree 2종류를 이야기한다. RDB의 인덱스로 사용하는 B+Tree를 이해하기 위해서는 B-Tree를 알아야한다.

참고로 B Tree의 B는 Balanced이다. 이는 B+Tree가 리프 노드까지 도달하는 거리\(Height\)를 일정하게 유지시켜주기 때문이다.

#### B-Tree

B-Tree 참고: [https://m.blog.naver.com/beaqon/221300200294](https://m.blog.naver.com/beaqon/221300200294)

참고: [https://ko.wikipedia.org/wiki/B\_트리](https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC)

#### B+Tree

B-Tree는 특성상 순회 작업이 힘들다. 때문에 색인 구조와 순차 접근에 대한 해결책으로 B+Tree가 등장했다. B-Tree와는 다음과 같은 차이점이 있다.

1. Branch 부분에 B-Tree는 실제 데이터가 있을 수 있지만, B+Tree에서 실제 데이터는 Leaf에만 존재한다.
2. leaf 노드들이 B+Tree에서는 double linked list로 연결되어 있다. 따라서 리프노드들의 수평적 탐색이 가능하다. 반면, B-Tree는 그렇지 못하다.

위 이유들로 B-Tree에서는 순회가 비효율적인 부분이 있었고 때문에 대부분의 DBMS에서는 B+Tree를 사용한다.

### 인덱스 탐색 과정

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색 두 가지로 분류할 수 있다.

#### 수직적 탐색

인덱스 수직적 탐색은 B+Tree에 정렬된 데이터 중 조건을 만족하는 첫번째 레코드를 찾는 것이다. 즉, 인덱스의 스캔 지점을 찾는 것을 수직적 탐색이라고 한다.

수직적 탐색이 가능한 이유는 루트를 포함해서 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 가진다. 따라서 루트에서 리프까지 수직적으로 탐색할 수 있다.

#### 수평적 탐색

수직적 탐색이 인덱스의 스캔 지점을 찾는 것이라면 수평적 탐색은 찾고자 하는 데이터가 더 이상 나타나지 않을 때까지 리프 블록을 스캔하는 것이다.

리프 블록에 실제 원하는 데이터가 있기 때문에 실제 데이터를 찾는 과정이다.

## 인덱스 기본 사용법

> MySQL 기준의 명령

1. 인덱스 생성

   ```text
    CREATE INDEX {인덱스 이름} ON {테이블 이름} ({컬럼명...}) 
   ```

2. 인덱스 삭제

   ```text
    DROP INDEX {인덱스 이름} ON {테이블 이름}
   ```

3. 인덱스 조회

   ```text
    SHOW INDEX FROM {테이블 이름}
   ```

### 인덱스 잘 사용하기

인덱스를 제대로 사용하기 위해서 알아야 할 몇가지 규칙이 있다.

1. 인덱스 컬럼을 가공하지 말 것.

   인덱스 컬럼을 가공하여 쿼리를 날리면 DB에서는 인덱스의 시작지점을 찾을 수 없다. 만약 학생 테이블에서 생년월일을 기준으로 인덱스를 만들었다고 가정한다. 이때 생년월일은 `yyyy-mm-dd`형식으로 저장되어 있다고 가정한다.

   ```text
    SELECT *
    FROM STUDENT
    WHERE substr(birthday, 15, 2) = '05';
   ```

   인덱스는 `yyyy-mm-dd`형식으로 저장되어있다. 하지만 위 SQL문은 월로만 조회하려고 한다. 이 경우 저장된 인덱스의 형식과 맞지 않기 때문에 스캔 시작점을 찾을 수 없다.

   **LIKE**를 사용했을 때도 마찬가지 문제가 발생한다. 학생의 이름을 예시로 든다면, `LIKE '박%'`은 인덱스를 탈 수 있다. 스캔 시작점이 명확하기 때문이다. \(박으로 시작하는 이름\)

   반면, `LIKE '%박'`은 시작점이 명확하지 못하기 때문에 인덱스를 탈 수 없다.

   **OR조건**을 사용할 때도 스캔 시작점이 명확하지 못하다. OR 조건은 2가지 조건을 동시에 주는 것인데 수직적 탐색으로 어느 한 시작지점을 정하지 못하기 때문이다.

2. 인덱스 선두 컬럼을 조건절에서 사용할 것.

   인덱스의 구조는 앞선 컬럼을 기준으로 차례로 정렬된다. 따라서 선두 컬럼을 기준으로 쿼리를 하면 그만큼 인덱스를 사용하는 의미가 커진다.

3. 인덱스를 잘 활용하면 sort 연산 생략 가능

   인덱스는 이미 컬럼을 기준으로 정렬이 되어있다. 때문에 인덱스를 잘 사용하면 정렬 연산을 생략할 수 있다.

   정렬연산 생략은 내림차순에도 적용가능하다. 이는 인덱스를 거꾸로 타면 되기 때문이다.

   단, ORDER BY 절에서 컬럼을 가공한다면 인덱스를 활용할 수 없기 때문에 정렬 연산이 이뤄진다.

### 다양한 인덱스 활용법

1. Index Range Scan

   기본적인 인덱스 활용법. 인덱스 루트에서 인덱스 리프까지 수직 탐색 후 리프블록을 필요한 범위에 따라 스캔하는 방식.

2. Index Full Scan

   인덱스 수직 탐색 없이 수평 탐색만 이용하여 모든 인덱스를 탐색하는 방법. 대개 검색을 위한 최적의 인덱스가 없을 경우 차선으로 선택되는 인덱스 활용법이다.

   보통 인덱스 선두 컬럼이 조건절에 없고 다른 인덱스의 컬럼이 조건절에 포함된 경우 사용된다.

   **효용성**

   만약 조회하는 데이터가 많다면 Index Full Scan은 오히려 성능상 손해를 볼 수 있다. Index는 Single Block I/O를 활용하기 때문에 많은 데이터 조회가 이뤄지는 경우는 Full Table Scan이 더 유리하다.

   단, 대부분의 데이터를 필터링하고 일부 데이터만 엑세스한다면 Index Full Scan이 효과적이다.

3. Index Unique Scan

   수직적 탐색으로만 데이터를 찾는 방식으로 Unique 인덱스를 등치 `=`조건으로 탐색하는 경우에 활용가능하다.

4. Index Skip Scan \(= Loose Index Scan\)

   인덱스 선두 컬럼을 조건절에 사용하지 않으면 기본적으로 Full Table Scan이다. 경우에 따라 옵티마이저는 Index Full Scan을 하기도 한다.

   만약 인덱스 선두 컬럼의 Distinct 갯수가 적고 후행 컬럼의 갯수는 많을 때 유용하게 사용할 수 있는 인덱스 활용법이다.

   그 밖에도 선두 컬럼에 대한 조건절이 있고 후행 컬럼이 조건절에 없어도 사용할 수 있다.

5. Index Fast Full Scan

   인덱스는 논리적 구조에 따라 순서를 보장하여 빠른 검색이 가능하도록 한다. 따라서 Index Full Scan도 이 같은 논리적 구조에 따라 스캔한다.

   단, 실제 물리적 구조는 정렬 순서가 아니라 뒤죽박죽으로 데이터가 저장되어있다. Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록은 읽어들인다.

   Index Fast Full Scan은 Multiblock I/O를 사용하므로 대량의 인덱스를 읽을 때 효과적이다. 단, 물리적으로 저장된 순서로 데이터를 가져오므로 결과집합이 정렬되어 있지는 않으며 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용할 수 있다.

6. Index Range Scan Descanding

   인덱스를 내림차순으로 조회하는 방식이다. 이론은 Index Range Scan과 동일하며 이를 반대로 조회한 방법이 바로 Index Range Scan Descanding이다.

## 2. 인덱스 튜닝

## I/O 메커니즘

### 인덱스 ROWID

인덱스를 스캔하는 이유는 검색 조건과 일치하는 소량의 데이터를 빠르게 찾고 테이블 레코드를 찾아가기 위한 주소값인 ROWID를 얻기 위함이다.

이때 인덱스 ROWID는 물리적 주소라기 보다는 논리적 주소에 가깝다. 찾은 테이블 레코드와 직접 연결된 것이 아닌 찾아가기 위한 논리적 주소 정보를 담고 있기 때문이다.

### 인덱스를 활용해 테이블 블록 찾는 과정

1. 인덱스 조회하여 조회를 원하는 데이터의 ROWID를 구한다.
2. 인덱스 리프 블록에서 얻은 ROWID를 분해하여 DBA \(Data Block Address\) 정보를 얻는다.
3. 버퍼캐시에 접근해 원하는 데이터 블록이 있는지 확인

   이때 읽고자 하는 DBA \(Data Block Address\)를 해시함수에 입력하여 해시 체인을 찾는다. 단, 버퍼 캐시에 동시 엑세스가 생길 수 있으므로 래치를 획득하는 과정이 필요하다.

4. 버퍼 캐시에 있다면 해당 데이터 블록 조회
5. 없다면 테이블 조회

이런 과정을 거치기 때문에 인덱스 ROWID를 활용한 조회는 생각보다 고비용구조이다.

## 인덱스 튜닝

### 인덱스 컬럼 추가

테이블 엑세스 최소화를 위해서 가장 일반적인 방법은 **인덱스에 컬럼을 추가하는 방법**이다.

기존 인덱스 구성을 변경하는 것은 이에 영향을 받는 쿼리들을 모두 검토해야하는 문제가 있으며 인덱스를 추가하는 것은 성능상 이슈가 발생할 수 있다.

따라서 현재 인덱스 구조에 컬럼을 추가하는 방식으로 성능 개선을 꾀할 수 있다.

### Covered Index

쿼리에 사용한 컬럼을 인덱스에서 모두 얻을 수 있는 경우 **Covered Index**라고 한다.

쿼리시에 사용하는 인덱스가 있다면 인덱스를 탐방한 후 테이블에 실제 데이터를 가져온다. 이때 인덱스 탐방만으로 쿼리에서 사용할 데이터를 모두 얻을 수 있으므로 랜덤 엑세스를 방지할 수 있다.

다만, 추가해야 할 컬럼이 많아 실제 적용이 곤란할 수 있다.

### Clustering Factor

특정 컬럼을 기준으로 데이터가 물리적으로 모여있는 정도를 Clustering Factor \(CF\)라고 한다. RDBMS는 하나의 ROW를 조회해도 하나의 블록을 가져와야한다. 따라서 물리적으로 모여있는 정도가 클수록 데이터를 찾는 속도가 빨라진다.

단, 위 방법은 인덱스 튜닝의 최후의 방법으로 사용된다. 일단 물리적으로 데이터를 조정해야하므로 번거로움이 있다. 또한 데이터가 새로 입력될 때마다 조정해줘야한다.

## 부분범위 처리

> OLTP 환경에서 대용량 데이터를 빠르게 핸들링할 수 있는 중요한 원리

아무리 조회한 데이터가 많더라도 서버 프로세스는 클라이언트에게서 fetch call을 받지 않으면 그대로 기다린다. 즉, DBMS가 읽은 데이터를 한 번에 전송하는 것이 아니라 먼저 읽은 데이터부터 일정량 전송하고 멈추기 때문이다.

이처럼 전체 쿼리 결과집합을 연속적으로 전송하는 것이 아닌 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 **부분범위 처리**라고 한다.

### 정렬 조건이 있을 경우

만약 ORDER BY를 적용하는 컬럼이 인덱스 선두 컬럼에 있다면 부분범위 처리가 가능하다. 인덱스는 항상 정렬된 상태를 가지기 때문이다.

그렇지 않다면 데이터 정렬을 마치고 난 후 클라이언트에게 데이터를 전송한다.

## 인덱스 스캔 효율화

인덱스 스캔 효율을 이야기 할 때 반드시 알아야하는 용어가 있다. 바로 **엑세스 조건**과 **필터 조건**이다.

인덱스 엑세스 조건은 **인덱스의 스캔 범위를 결정**한다. 즉, 수직 탐색으로 인덱스 스캔 시작점을 정하고 어디까지 인덱스 리프 블록을 스캔할 지 결정하는 조건이다.

필터조건은 테이블로 엑세스할지를 결정하는 조건이다. 인덱스 스캔 효율은 엑세스 조건을 잘 정의하여 인덱스를 조회하는 횟수를 줄일수록 극대화된다.

따라서 인덱스 스캔 효율은 **인덱스 선행 컬럼이 등치조건**일수록 극대화된다.

